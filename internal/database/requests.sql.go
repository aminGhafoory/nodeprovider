// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.18.0
// source: requests.sql

package database

import (
	"context"
	"database/sql"

	"github.com/google/uuid"
)

const createReq = `-- name: CreateReq :one
INSERT INTO requests(
    nodeID,
    responsetime,
    successful,
    last_fetched_at
)VALUES(
    $1,$2,$3,$4
)
RETURNING request_id, nodeid, responsetime, successful, last_fetched_at
`

type CreateReqParams struct {
	Nodeid        uuid.UUID
	Responsetime  sql.NullInt64
	Successful    bool
	LastFetchedAt sql.NullTime
}

func (q *Queries) CreateReq(ctx context.Context, arg CreateReqParams) (Request, error) {
	row := q.db.QueryRowContext(ctx, createReq,
		arg.Nodeid,
		arg.Responsetime,
		arg.Successful,
		arg.LastFetchedAt,
	)
	var i Request
	err := row.Scan(
		&i.RequestID,
		&i.Nodeid,
		&i.Responsetime,
		&i.Successful,
		&i.LastFetchedAt,
	)
	return i, err
}

const getNextNodestoFetch = `-- name: GetNextNodestoFetch :many
SELECT nodeid, nodeurl, chain_id, chain_name, last_fetched_at, created_at, updated_at FROM nodes
ORDER BY last_fetched_at ASC NULLS FIRST
LIMIT $1
`

func (q *Queries) GetNextNodestoFetch(ctx context.Context, limit int32) ([]Node, error) {
	rows, err := q.db.QueryContext(ctx, getNextNodestoFetch, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Node
	for rows.Next() {
		var i Node
		if err := rows.Scan(
			&i.Nodeid,
			&i.Nodeurl,
			&i.ChainID,
			&i.ChainName,
			&i.LastFetchedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const markNodesASFetched = `-- name: MarkNodesASFetched :one
UPDATE nodes
SET
    last_fetched_at = NOW(),
    updated_at = NOW()
WHERE 
    nodeID = $1
RETURNING nodeid, nodeurl, chain_id, chain_name, last_fetched_at, created_at, updated_at
`

func (q *Queries) MarkNodesASFetched(ctx context.Context, nodeid uuid.UUID) (Node, error) {
	row := q.db.QueryRowContext(ctx, markNodesASFetched, nodeid)
	var i Node
	err := row.Scan(
		&i.Nodeid,
		&i.Nodeurl,
		&i.ChainID,
		&i.ChainName,
		&i.LastFetchedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
